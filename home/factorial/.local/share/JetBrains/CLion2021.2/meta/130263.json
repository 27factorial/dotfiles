{"id":130263,"xmlId":"org.elixir_lang","name":"Elixir","description":"<p></p>\n<p>\n<a href=\"https://github.com/sponsors/KronicDeth\">\n  ❤️ Sponsor\n</a>\n</p><table>\n  <thead>\n    <tr>\n      <td>Stat</td>\n      <td>Amount</td>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Minimum</td>\n      <td>$1.00</td>\n    </tr>\n    <tr>\n      <td>Median</td>\n      <td>$6.25</td>\n    </tr>\n    <tr>\n      <td>Mean</td>\n      <td>$12.52</td>\n    </tr>\n    <tr>\n      <td>Maximum</td>\n      <td>$200.00</td>\n    </tr>\n  </tbody>\n</table>\n<p></p>\n<p>\nElixir support for JetBrains IDEs\n</p><ul>\n  <li>IntelliJ IDEA</li>\n  <li>AppCode</li>\n  <li>CLion</li>\n  <li>Goland</li>\n  <li>PhpStorm</li>\n  <li>PyCharm</li>\n  <li>Rubymine</li>\n  <li>WebStorm</li>\n</ul>\n<b>Features:</b>\n<ul>\n  <li>Elixir SDK with Internal Erlang SDK</li>\n  <li>Syntax highlighting and semantic annotation</li>\n  <li>Grammar Parsing (So good, it found bugs in the native Elixir tokenizer and parser)</li>\n  <li>Inspections with Quick Fixes</li>\n  <li>Code Folding</li>\n  <li>Commenter</li>\n  <li>File Templates</li>\n  <li>\n    Graphical Debugger - works on all Run Configurations\n    <ul>\n      <li>Breakpoints (in <code>.ex</code> <strong>and</strong> <code>.eex</code> file)</li>\n      <li>Stepping</li>\n      <li>\n        Stack Frames\n        <ul>\n          <li>Go up and Down stack without stepping program</li>\n          <li>Collapse and expanded nested data structures in local variables</li>\n          <li>Evaluate code in any frame in Evaluator</li>\n        </ul>\n      </li>\n      <li>Customizable Module Filters</li>\n    </ul>\n  </li>\n  <li>Delimiter/Brace Auto-insertion</li>\n  <li>Delimiter/Brace Matching</li>\n  <li>Embedded Elixir (EEx) Templates</li>\n  <li>Compilation</li>\n  <li>Decompilation</li>\n  <li>Dissassembly</li>\n  <li>BEAM Chunks viewer</li>\n  <li>\n    Run Configurations\n    <ul>\n      <li>Distillery Release CLI</li>\n      <li>Elixir</li>\n      <li>Elixir Mix</li>\n      <li>Elixir Mix ExUnit</li>\n      <li>IEx</li>\n      <li>IEx Mix</li>\n    </ul>\n  </li>\n  <li>\n    Completion\n    <ul>\n      <li>\n        Module Names\n        <ul>\n          <li>Aliases in Elixir Source</li>\n          <li>Atoms in Elixir Source</li>\n          <li>Decompiled Aliases from <code>.beam</code> files (Elixir SDK, Erlang SDK, and <code>_build</code>)</li>\n          <li>Decompiled Atoms from <code>.beam</code> files (Elixir SDK, Erlang SDK, and <code>_build</code>)</li>\n        </ul>\n      </li>\n      <li>\n        Function and Macro Names\n        <ul>\n          <li>Elixir Source</li>\n          <li>Decompiled from <code>.beam</code> files (Elixir SDK, Erlang SDK, and <code>_build</code>)</li>\n        </ul>\n      </li>\n      <li>Module Attributes</li>\n      <li>Parameters and Variables</li>\n    </ul>\n  </li>\n  <li>Formatting</li>\n  <li>\n    Go To\n    <ul>\n      <li>Definition (of macro or function from usage)</li>\n      <li>\n        Symbol\n        </li><li>Module Aliases (Source or Decompiled)</li>\n        <li>Function and Macro Names (Source or Decompiled)</li>\n      \n      <li>Test</li>\n      <li>Test Subject</li>\n    </ul>\n  </li>\n  <li>Find Usage</li>\n  <li>\n    Refactor\n    <ul>\n      <li>\n        Rename\n        <ul>\n          <li>Moduel Attribute</li>\n          <li>Parameters and Variables</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>\n    <p>Spellchecking</p>\n\n    <p>Dictionaries for common dependencies:\n      </p><ul>\n        <li>Elixir</li>\n        <li>Ecto</li>\n      </ul>\n    <p></p>\n  </li>\n  <li>Structure View</li>\n</ul>","tags":["Languages"],"vendor":"Elle Imhoff","version":"11.13.0","notes":"<h1>v11.13.0</h1>\n<ul>\n  <li>\n    <p>Bug Fixes</p>\n    <ul>\n      <li>Remove bintray repositories.</li>\n    </ul>\n  </li>\n  <li>\n    <p>Enhancements</p>\n    <ul>\n      <li>Update build to IntelliJ IDEA 2021.2.</li>\n      <li>Upgrade to Gradle 7.1.1.</li>\n      <li>Expand compatibility range to 2021.1.2-2021.2.</li>\n    </ul>\n  </li>\n</ul>\n<h1>v11.12.0</h1>\n<ul>\n  <li>\n    <p>Bug Fixes</p>\n    <ul>\n      <li>\n        <p>Find <code>Dep</code>s in function calls in the <code>deps()</code> list.</p>\n      </li>\n      <li>\n        <p><code>Dep.putPath</code> from a variable.</p>\n      </li>\n      <li>\n        <p>Treat <code>Memoize</code> <code>defmemo</code> as <code>def</code> and <code>defmemop</code> as <code>defp</code>.</p>\n      </li>\n      <li>\n        <p>Resolve <code>exception/1</code> and <code>message/1</code> to <code>defexception</code>.</p>\n      </li>\n      <li>\n        <p>Resolve to callbacks when searching in any module.</p>\n      </li>\n      <li>\n        <p>Support arity intervals for unquote_splicing in parameters</p>\n        <p>Functions defined with unquote_splicing, such as <code>Ecto.Schema.__schema/2</code>:</p>\n        <div><pre><span>for</span> clauses <span>&lt;-</span> <span>Ecto</span>.<span>Schema</span>.<span>__schema__</span>(fields, field_sources, assocs, embeds),\n    {args, body} <span>&lt;-</span> clauses <span>do</span>\n  <span>def</span> <span>__schema__</span>(<span>unquote_splicing</span>(args)), <span>do:</span> <span>unquote</span>(body)\n<span>end</span></pre><div>\n          \n            \n              \n            \n            \n              \n            \n          \n        </div></div>\n        <p>Need to have their arity not be the number of PsiElements in the parentheses.  Any call to <code>unquote_splicing(...)</code> can end up have 0 to infinite parameters, so it means when one is saw, the range of <code>minimum...maximum</code> should change to an open interval of <code>minimum...</code>.  This required changing <code>IntRange resolvedFinalArityChange()</code> to <code>ArityInterval resolvedFinalArityInterval()</code> on all <code>Call</code>s, which was a large change.  It also meant changing a lot of ArityRange types to ArityInterval, and NameArityRange to NameArityInterval, which influenced the variable names.</p>\n        <p>Since all Calls support ArityIntervals now and not just special forms and Ecto DSLs, exportArity is changed to always state the ResolveState, so that the special form changes can be integrated for all callers.</p>\n        <p>The actual implementation of CallImpl.resolvedFinalArityRange is changes to fold over the ArityInterval:</p>\n        <ul>\n          <li>Normal arguments increase the minimum and maximum.</li>\n          <li>Default arguments increase only the maximum.</li>\n          <li>unquote_splicing changes the maximum to null to indicate the interval is half open.</li>\n        </ul>\n      </li>\n      <li>Convert MissingSDK errors for Dialyzer into Notifications.</li>\n      <li>\n        Log element in psi.scope.Type instead of using <code>TODO()</code><br>\n        Error will still be reported, but there will be enough information to triage and since <code>true</code> is\n        returned now it won't stop the type resolving from working.\n      </li>\n      <li>\n        Add missing mix deps options to non-path influencing list:\n        <ul>\n          <li>env</li>\n          <li>manager</li>\n          <li>repo</li>\n          <li>sparse</li>\n          <li>submodules</li>\n          <li>system_env</li>\n        </ul>\n      </li>\n      <li>\n        Fix Fix incorrect <code>OuterElementType</code> in <code>eex.lexer.TemplateData</code>.<br>\n        The <code>EEX</code> <code>IElementType</code> needs to use <code>OuterLanguageElementType</code> instead of the\n        direct <code>eex.psi.TokenType</code>.\n      </li>\n      <li>\n        Run <code>QualifiedAlias#text</code> in <code>runReadAction</code> for <code>QualifiedAlias#name</code>\n      </li>\n      <li>\n        Return <code>null</code> <code>Chunk</code> instead of throwing <code>IOException</code> when read incomplete.<br>\n        Incomplete reads happen often due to incomplete writes to the file system being read in. As such, they shouldn't\n        generate error reports and instead should be silently ignored.\n      </li>\n      <li>\n        Implement <code>beam.FileEditor#getFile</code> to fix <code>DeprecatedMethodException</code> as the default\n        implementation is now deprecated and requires an explicit implementation.\n      </li>\n      <li>\n        Use <code>TabbedPaneWrapper.AsJBTabs</code> instead of <code>JBTabbedPane</code> for \"BEAM Chunks\" tabs.<br>\n        I'm not sure why <code>JBTabbedPane</code> stopped showing its labels sometime in the 2020.X IDE version series,\n        but by debugging when \"BEAM Chunks\" name was retrieved I found that the bottom tabs used\n        <code>TabbedPaneWrapper.asJBTabs</code>.  Using that, the labels reappeared.\n      </li>\n      <li>\n        Don't require Alias qualifier to be a <code>PsiNamedElement</code><br>\n        It can be an <code>ElixirAtom</code> and getting the reference will still work.\n      </li>\n      <li><code>Any.isDecompiled</code> for <code>CallDefinitionHead</code>.</li>\n    </ul>\n  </li>\n  <li>\n    <p>Enhancements</p>\n    <ul>\n      <li>Only descend into modular children of modular for Module scope.  Prevents recursion loops on use calls.</li>\n      <li>Don't search for unquoted variable value variable is value for <code>do:</code>.</li>\n      <li>Protect from <code>IndexNotReady</code> in <code>resolver.Module.multiResolveProject</code>.</li>\n      <li>Stop walking unquoted variable that resolves to a parameter.</li>\n      <li>\n        Walk case in <code>__using__</code> to find quote in any clause.  Fixes resolving test macro from\n        <code>use PowerAssert</code>\n      </li>\n      <li>\n        Resolve functions declared in <code>quote</code>'s scope when <code>block</code> injected with\n        <code>unquote(block)</code>.<br>\n        Fixes resolving <code>field</code>, <code>timestamps</code>, and <code>index</code> in <code>schema</code> for\n        <code>use Yacto.Schema</code> as it makes the <code>block</code> see the <code>import Yacto.Schema</code> above\n        <code>unquote(block)</code> in the <code>quote</code> in <code>schema(..., do: block)</code>.\n      </li>\n    </ul>\n  </li>\n</ul>\n<h1>v11.11.0</h1>\n<ul>\n  <li>\n    <p>Enhancements</p>\n    <ul>\n      <li>\n        <p>Reference Resolution</p>\n        <ul>\n          <li>\n            <p>\n              Allow any Alias in a chain to have references.<br>\n              This allows going to the declaration of <code>Phoenix</code>, <code>Phoenix.LiveView</code>, or\n              <code>Phoenix.LiveView.Socket</code> depending on whether you're on the <code>Phoenix</code>,\n              <code>LiveView</code>, or <code>Socket</code> Alias, respectively, in the chain.\n            </p>\n            <ul>\n              <li>\n                <p>\n                  Allow any Alias in Qualified Alias to be resolved<br>\n                  This allows going to the declaration of Phoenix, Phoenix.LiveView, or Phoenix.LiveView.Socket\n                  depending on whether you're<br>\n                  on the Phoenix, LiveView, or Socket Alias, respectively, in the chain.\n                </p>\n              </li>\n              <li>\n                <p>Update DocumentationProvider to work with improved Alias resolution</p>\n                <p>\n                  Without these changes the DocumentationProvider double-resolves and so ends up showing the docs for\n                  <code>def</code> and <code>defmodule</code>, instead of the call definition clause or module,\n                  respectively.\n                </p>\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>\n              Reimplement Module references<br>\n              Instead of references for only the outermost QualifiableAlias, there is a reference for each right-most\n              Alias at a given position, so instead of there only be a reference to <code>App.Context.Schema</code> in\n              <code>App.Context.Schema</code>, there is now a reference to <code>App</code> in the <code>App</code>\n              prefix, a reference to <code>App.Context</code> in <code>Context</code> in <code>App.Context</code>, and a\n              reference to <code>App.Context.Schema</code> in <code>Schema</code> in <code>App.Context.Schema</code>.\n              Not only is this more useful, being able to jump to parent namespaces, but it fixed some of the capability\n              issues with Go To Definition in the 2020 line of IDEs.  This approach of using\n              <code>getRangeInElement</code> to target the range of the right-most Alias, while the element was still\n              the parent that contained, but did not go beyond the Alias, was tried after having references only on\n              <code>Alias</code>es and not <code>QualifiedAlias</code>es did not fix completion issues.  It was the\n              while debugging Go To Declaration actions and noticing they were sensitive to the range in element AND the\n              <a href=\"https://github.com/JetBrains/intellij-community/blob/f66e9644fa683fba22f4ce9e30c037720f745989/platform/core-api/src/com/intellij/psi/PsiReference.java#L49-L62\">\n                docs for PsiReference#getRangeInElement\n              </a> that I realized that the Go To Declaration and Completion has a hidden requirement that References\n              for things that behave like namespaces have to work this way.\n            </p>\n            <ul>\n              <li>Use <code>ModularName</code> index for Module Variants<br>\n                Have a smaller index to iterate and remove need for the <code>isAlias</code> check.</li>\n            </ul>\n          </li>\n          <li>\n            <p>Limit Elixir Module resolution to same JetBrains Project Module</p>\n            <ul>\n              <li>\n                Change the <code>GlobalSearchScope</code> from <code>allProject</code> to\n                <code>moduleWithDependenciesAndLibrariesScope</code> for faster searching on multi-module projects.\n                <ul>\n                  <li>Set <code>includeTests</code> based whether the referring element is in a test directory.</li>\n                </ul>\n              </li>\n              <li>\n                Use <code>StubIndex#processElements</code> instead of home grown <code>forEachNavigationElement</code> as\n                <code>processElements</code> is more efficient.\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>Favor Module <code>ResolveResults</code> under same <code>Module</code> content roots<br>\n              This should favor deps sources in the same module.</p>\n          </li>\n          <li>\n            <p>\n              Iterate <code>function</code> body in <code>unquote(function())</code> when iterating call definition\n              clauses in <code>quote</code><br>\n              Treats it <code>function</code> body the same as a <code>__using__</code> body.\n            </p>\n          </li>\n          <li>\n            <p>Standardized preferred <code>ResolveResult</code> filters between Callables and Modules</p>\n            <ol>\n              <li>Prefer valid results as long as it doesn't leave no results.</li>\n              <li>Prefer results in the same module as long as it doesn't leave no results.</li>\n            </ol>\n            <p>In Go To Declaration also:</p>\n            <ol start=\"3\">\n              <li>Prefer results in source (that aren't decompiled) as long as it doesn't leave no results.</li>\n            </ol>\n          </li>\n          <li>\n            <p>Use the second argument to <code>use</code> to determine which function is called with apply/3</p>\n            <p>\n              This pattern is used in Phoenix <code>__using__</code>, so this lets to differentiate whether\n              <code>Plug.Conn.assign/3</code> or <code>Phoenix.LiveSocket.assign/3</code> is resolved in a Controller,\n              LiveComponent, or LiveView.\n            </p>\n          </li>\n          <li>\n            <p>In LEEx Templates</p>\n            <ul>\n              <li>\n                Resolve function calls in <code>*.html.leex</code> templates to functions defined in the corresponding\n                LiveComponent/View module.\n              </li>\n              <li>Assigns\n                <ul>\n                  <li>\n                    Resolve assigns in LEEx templates to the keyword key in <code>assign/3</code> calls in\n                    <code>update/2</code> in the LiveComponent or LiveView<br>\n                    Had to add back in a <code>TargetElementEvaluator</code>, so that the\n                    <code>UnqualifiedNoArgumentCall</code> (<code>name</code>) that is the identifier in an assign\n                    (<code>@name</code>) was not counted as valid target for Find Usages / Go To Declaration by itself.\n                  </li>\n                  <li>\n                    Search for assigns in all call definitions in view module<br>\n                    Expand from just <code>update</code> to any call definition to cover helper functions and other\n                    callbacks. Don't stop on the first valid match because with helper functions and multiple callbacks,\n                    the last write isn't obvious.\n                  </li>\n                  <li>Resolve assigns set with <code>assign/3</code></li>\n                  <li>Look for <code>assign</code> calls in <code>|&gt;</code> pipelines</li>\n                  <li>Resolve assigns set with <code>assign_new/3</code></li>\n                  <li>Resolve @live_action to where it is assigned Phoenix.LiveView.Channel.assign_action/2</li>\n                  <li>Find assigns in maps for assign/2<br>\n                    Since assign/2 accepts either a keyword list or a map, check in both types.</li>\n                  <li>Resolve <code>@myself</code> to where it is set in <code>render_pending_components</code></li>\n                  <li>Resolve assigns in macros with do blocks like <code>case</code> and <code>if</code></li>\n                  <li>\n                    Find assigns in <code>live_component</code> calls<br>\n                    If an assign can't be found in the body of a LiveComponent module, then it maybe passed through from\n                    the <code>live_component</code> call itself, so look for any references to the view module\n                    (the LiveComponent) and if it is a <code>live_component</code> call, then look at those assigns to\n                    try to resolve the assign name.\n                  </li>\n                  <li>\n                    Resolve assigns to <code>live_modal</code> calls<br>\n                    <code>live_modal</code> is not built into <code>phoenix_live_view</code>, but it is generated by\n                    <code>phx.gen.live</code>, so most projects will have it.&nbsp; This allows <code>return_to</code>,\n                    which is used use in <code>live_modal</code>, to be resolved.\n                  </li>\n                  <li>Resolve <code>@socket</code> to last socket variable or call in view module.</li>\n                  <li>Resolve <code>@flash</code> to <code>put_flash/3</code> calls.</li>\n                  <li>\n                    Resolve <code>@inner_content</code> to <code>Phoenix.LiveView.Utils.to_rendered/2</code> setting the\n                    assign with <code>put_in</code>\n                  </li>\n                </ul>\n              </li>\n              <li>\n                Resolve aliases in <code>.leex</code> templates<br>\n                Generalize the <code>.leex</code> and <code>use</code> walking from call definition clauses to any scope\n                processor lambda, so it can be used to resolve uses of <code>Routes</code> in <code>.leex</code>\n                templates.\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>Resolve Types</p>\n            <ul>\n              <li>Have separate references specifically for Types.</li>\n              <li>\n                Resolve to both types declared with <code>@type</code>, <code>@typep</code>, or <code>@opaque</code>;\n                and named type parameters.\n              </li>\n              <li>Process declarations for <code>@type</code>, <code>@typep</code>, and <code>@opaque</code>.</li>\n              <li>Count <code>@callback</code> as declaring a Type</li>\n              <li>\n                Resolve type <code>t</code> for <code>defprotocol</code> to where it is defined in\n                <code>Protocol.__protocol__</code><br>\n                Unfortunately, this ties all protocol's <code>t</code> to the same element, so Find Usage finds all\n                protocol's types instead of just a specific module's type, but this works for projects that have source,\n                but not yet compiled.\n                <ul>\n                  <li>Favor protocol-specific decompiled <code>@type t</code> when available.</li>\n                </ul>\n              </li>\n              <li>Resolve type variable to the keyword key in guards.</li>\n              <li><code>__MODULE__</code></li>\n            </ul>\n          </li>\n          <li>\n            <p>\n              Favor source over decompiled per name instead of overall for <code>ResolveResultOrderedSet</code><br>\n              This allows the <code>Routes</code> alias to be resolved to the both the\n              <code>MyAppWeb.Router.Helpers</code> in <code>alias MyAppWeb.Router.Helpers, as: Routes</code> in the\n              source of <code>MyAppWeb</code>, but also the decompiled <code>MyAppWeb.Router.Helpers</code>, which is\n              necessary as <code>MyAppWeb.Router.Helpers</code> is produced on compile from <code>router.ex</code>.\n            </p>\n          </li>\n          <li>\n            <p>Resolve references through <code>defdelegate</code> calls.</p>\n          </li>\n          <li>\n            <p>Resolve <code>code_reloading?</code> in MyApp.Endpoint</p>\n            <p>The generated <code>MyApp.Endpoint</code> for <code>mix phx.new</code> has a section to enable code-reloading at compile time:</p>\n            <div><pre><span><span>#</span> Code reloading can be explicitly enabled under the</span>\n<span><span>#</span> :code_reloader configuration of your endpoint.</span>\n<span>if</span> code_reloading? <span>do</span>\n  <span>socket</span>(<span><span>\"</span>/phoenix/live_reload/socket<span>\"</span></span>, <span>Phoenix</span>.<span>LiveReloader</span>.<span>Socket</span>)\n  <span>plug</span>(<span>Phoenix</span>.<span>LiveReloader</span>)\n  <span>plug</span>(<span>Phoenix</span>.<span>CodeReloader</span>)\n<span>end</span></pre><div>\n              \n                \n                  \n                \n                \n                  \n                \n              \n            </div></div>\n            <p>\n              Previously, <code>code_reloading?</code> variable would not resolve because psi.scope.Variable ignored\n              <code>use</code> calls, not <code>use</code> calls are entered and the <code>var!(code_reloading?)</code>\n              is found in <code>Phoenix.Endpoint.config/1</code> by way of the <code>unquote(config(opts))</code> call\n              in the <code>quote</code> block in <code>__using__(opts)</code>.\n            </p>\n          </li>\n          <li>\n            <p>Resolve qualified calls with unknown resolvable qualifier using only relative identifier and arity.</p>\n          </li>\n          <li>\n            <p><code>@spec</code></p>\n            <ul>\n              <li>Resolve <code>@spec</code> to <code>defdelegate</code> calls.</li>\n              <li>Resolve <code>@specs</code> to the definitions if the definitions are in a for comprehension</li>\n            </ul>\n          </li>\n          <li>\n            <p><code>Ecto</code></p>\n            <ul>\n              <li><code>Query</code>\n                <ul>\n                  <li>\n                    <p>Resolve reference variables in <code>Ecto.Query</code></p>\n                    <ul>\n                      <li>\n                        Reference variables are introduced in as the left operand of <code>in</code> passed to\n                        <code>from/2</code> and the <code>join:</code> keyword in <code>from/2</code>.\n                      </li>\n                      <li><code>join/3-5</code></li>\n                      <li>Resolve bindings in <code>select/2-3</code>.</li>\n                      <li>Resolve reference variables in <code>where/2,3</code> binding.<br>\n                        Also add support for resolving <code>a</code> in <code>[{^assoc, a}]</code> binding.</li>\n                      <li>Resolve <code>bindings</code> in <code>group_by/2-3</code>.</li>\n                      <li>Resolve <code>bindings</code> and <code>expressions</code> in <code>order_by/2-3</code>.</li>\n                      <li>Resolve <code>bindings</code> in <code>having/2-3</code>.</li>\n                      <li>Add <code>select_merge</code> to declaring <code>Ecto.Query</code> macros.</li>\n                      <li>Add <code>distinct/2-3</code> as a declaring <code>Ecto.Query</code> macro.</li>\n                    </ul>\n                  </li>\n                  <li>\n                    <p>Resolve <code>field</code> calls in Ecto <code>schema</code> blocks</p>\n                    <p>How <code>field</code> works in <code>schema</code> for <code>Ecto.Schema</code></p>\n                    <ol>\n                      <li><code>use Ecto.Schema</code></li>\n                      <li><code>Ecto.Schema.__using__</code></li>\n                      <li><code>import Ecto.Schema, only: [schema: 2, embedded_schema: 1]</code>`</li>\n                    </ol>\n                    <p>\n                      Note that only the outer DSLs, schema and embedded_schema are available even though field/2 is\n                      defined in Ecto.Schema.\n                    </p>\n                    <p>So when you call <code>schema ... do</code></p>\n                    <ol>\n                      <li><code>defmacro schema(source, [do: block])</code></li>\n                      <li><code>schema(__CALLER__, source, true, :id, block)</code></li>\n                      <li><code>defp schema(caller, source, meta?, type, block)</code></li>\n                      <li>There's a big <code>prelude = quote do</code> quote block</li>\n                    </ol>\n                    <p>At the end of prelude there is</p>\n                    <div><pre><span>try</span> <span>do</span>\n  <span>import</span> <span>Ecto</span>.<span>Schema</span>\n  <span>unquote</span>(block)\n<span>after</span>\n  <span>:ok</span>\n<span>end</span></pre><div>\n                      \n                        \n                          \n                        \n                        \n                          \n                        \n                      \n                    </div></div>\n                    <p>\n                      Hey! An <code>import Ecto.Schema</code>, but <code>prelude</code> is just floating as a variable.&nbsp;\n                      At the end of&nbsp; <code>defp schema(caller, source, meta?, type, block)</code> is\n                    </p>\n                    <div><pre><span>quote</span> <span>do</span>\n  <span>unquote</span>(prelude)\n  <span>unquote</span>(postlude)\n<span>end</span></pre><div>\n                      \n                        \n                          \n                        \n                        \n                          \n                        \n                      \n                    </div></div>\n                    <p>So to statically analyze an <code>Ecto.Schema</code> module.</p>\n                    <ol>\n                      <li>\n                        Resolve <code>schema/2</code> to <code>defmacro schema</code> by walking the <code>use</code>,\n                        <code>__using__</code>, <code>quote</code>, and <code>import</code>.\n                      </li>\n                      <li>\n                        Inside the <code>schema/2</code> (or macros in general if you want to get fancy 💅 and support\n                        more DSLs),\n                      </li>\n                      <li>Go into the body of the macro.&nbsp; If there's a call, resolve it</li>\n                      <li>Go into the called function</li>\n                      <li>\n                        Look for a <code>quote</code> block at the end (the same as my current <code>__using__</code>\n                        support)\n                      </li>\n                      <li>\n                        If there's a <code>Call</code> inside an <code>unquote</code> see if you can resolve it to a\n                        variable in addition to a call definition (which is already supported for Phoenix).\n                      </li>\n                      <li>\n                        If it's a variable, check it's value.&nbsp; If it's a <code>quote</code>, use the quote block\n                        handling\n                      </li>\n                      <li>In the quote block handling add support for <code>try</code></li>\n                      <li>\n                        Walk the <code>try</code> and see the <code>import</code>, walk the <code>import</code> to find\n                        <code>Ecto.Schema.field/2</code>\n                      </li>\n                    </ol>\n                  </li>\n                  <li>\n                    <p><code>API</code></p>\n                    <ul>\n                      <li>Resolve <code>Ecto.Query.API</code> functions in <code>Ecto.Query</code></li>\n                      <li><code>from(order_by: ...)</code></li>\n                      <li><code>from(select: ...)</code>\n                        <ul>\n                          <li><code>from(select: tuple())</code></li>\n                        </ul>\n                      </li>\n                      <li><code>from(where: ...)</code></li>\n                      <li><code>group_by/2-3</code></li>\n                      <li><code>having/2-3</code></li>\n                      <li><code>select/2-3</code> <code>expr</code> argument</li>\n                      <li><code>where</code></li>\n                      <li>Resolve <code>Ecto.Query.API.fragment</code> to arity interval <code>0..</code>.</li>\n                      <li>\n                        Resolve <code>fragment</code> nested in other <code>Ecto.Query.API</code> call like\n                        <code>type</code>.\n                      </li>\n                      <li>\n                        Walk <code>rightOperand</code> of <code>join(..., ... in ..., ...)</code> for\n                        <code>Ecto.Query.API</code> usages like <code>fragment</code>.\n                      </li>\n                    </ul>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>Resolve module attributes defined in <code>use</code> <code>__using__</code> <code>quote</code> block</p>\n            <ul>\n              <li>\n                Change <code>org.elixir_lang.reference.resolver.ModuleAttribute</code> to use\n                <code>PsiScopeProcessor</code> for non-<code>@for</code> and non-<code>@protocol</code> instead of\n                custom logic.\n              </li>\n              <li>\n                Don't descend into a <code>use</code> if the <code>ENTRANCE</code> is an ancestor since that means the\n                <code>Alias</code> on the <code>use</code> is probably being resolved.\n              </li>\n              <li>\n                <code>AtUnqualifiedNoParenthesesCall.processDeclarations</code> will call <code>processor.execute</code>\n                when it isn't a type spec.\n              </li>\n              <li>\n                The <code>UseScopeSelector</code> for <code>AtUnqualifiedNoParenthesesCallImpl</code> has been changed\n                to <code>SELF_AND_FOLLOWING_SIBLINGS</code> since the module attribute is used that way.&nbsp; The previous\n                <code>SELF</code> value was when the <code>UseScopeSelector</code> only applied to variables.\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>\"Elixir References\" inspection for finding unresolved or invalid references.</p>\n        <ul>\n          <li><code>visitAtNonNumericOperation</code><br>\n            Helps \"Elixir References\" find unresolved assigns.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Strip <code>AccessExpression</code>s from <code>Qualified</code> qualifiers automatically</p>\n      </li>\n      <li>\n        <p>Documentation</p>\n        <ul>\n          <li>\n            Show <code>deprecated</code>, <code>impl</code>, and <code>spec</code>, and actual heads in documentation\n            for source functions\n          </li>\n          <li>Merge <code>Documentation</code> across multiple arities when arity of lookup is ambiguous.</li>\n        </ul>\n      </li>\n      <li>\n        <p>\n          Find variables defined in EEx element<br>\n          Finds variables defined in EEx PsiElement by creating them the same as a StabBody, which means that the\n          siblings are checked backwards from the last parent.&nbsp; This fixes resolving the <code>f</code> from\n          <code>f = form_for ...</code> in <code>*input f ...</code> in LiveView FormComponent templates.\n        </p>\n      </li>\n      <li>\n        <p>Highlight named parameters in types.</p>\n      </li>\n      <li>\n        <p>Decompilation</p>\n        <ul>\n          <li>\n            Fake built-in types by decompiling in <code>:erlang.beam</code><br>\n            For type reference resolution of built-in types to work, they need to be defined somewhere.&nbsp; IntelliJ Erlang\n            does this by looping usages back on themselves, but this leads to Find Usages not working for built-in types\n            since each usage is a distinct declaration.&nbsp; By instead defining the types in decompiled\n            <code>:erlang.beam</code> (even though they aren't actually defined there), there is a shared location for\n            all reference to point to and then check for Find Usages.\n          </li>\n          <li>Decompile types from EEP-48 documentation.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Descend into body of <code>unless</code> in <code>quote</code> for <code>treeWalkUp</code>.</p>\n      </li>\n      <li>\n        <p>Descend into <code>for</code> when looking for call definition clauses.</p>\n      </li>\n      <li>\n        <p>\n          <code>QuoteMacro.treeWalkUp</code> into <code>if</code><br>\n          <code>unless</code> was already walked, but not <code>if</code>.&nbsp; Fixes resolving <code>Repo.preload/2</code>,\n          which is defined inside an <code>if</code> in <code>use Ecto.Repo</code>'s <code>__using__</code>.\n        </p>\n      </li>\n      <li>\n        <p>Add <code>defguard</code> and <code>defguardp</code> to CallDefinitionClause.<code>is</code>.</p>\n      </li>\n      <li>\n        <p>Don't generate a reference for <code>Elixir</code><br>\n          <code>Elixir</code> is not declared anywhere. It is the namespace of all Aliases.</p>\n      </li>\n      <li>\n        <p>Refactor how sibling sequences are walked<br>\n          Port filtering out comments, white space and end of expressions from <code>siblingExpression</code>.</p>\n      </li>\n      <li>\n        <p>Reimplement <code>fullyQualifiedName</code></p>\n        <p>\n          Eliminate the specialization for <code>ElixirAlias</code> AND <code>QualifiableAlias</code> as which was\n          picked as based on the static casted type. <code>fullyQualifiedName</code> will include the following:\n        </p>\n        <ul>\n          <li>Convert <code>__MODULE__</code> to the enclosing modular canonical name</li>\n          <li>Combine an ElixirAlias with its qualifier\n            <ul>\n              <li>\n                If in a <code>ElixirMultipleAliases</code> will combine the qualifier (<code>qualifier.{...}</code>)\n                outside the <code>{}</code> with the relative name inside <code>...{relative, ...}</code>.\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>EEx</p>\n        <ul>\n          <li>\n            <code>viewFile</code> for <code>.eex</code> files used in same directory as <code>.ex</code> using\n            <code>EEx.function_from_file</code>.\n          </li>\n          <li>Resolve function calls to those defined by <code>EEx.function_from_file/3-5</code>.</li>\n          <li>Find view modules for templates under the <code>templates</code> directory.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Walk <code>quote</code> macros for sibling call definitions</p>\n      </li>\n      <li>\n        <p>Always fallback to name/arity in any module if callable not resolved in scope</p>\n      </li>\n      <li>\n        <p>Resolve uses of aliased name produced by <code>alias __MODULE__</code></p>\n      </li>\n      <li>Updates\n        <ul>\n          <li>IntelliJ IDEA build version to 2021.1.2\n            <ul>\n              <li>Update <code>ParsingTestCase</code> to latest APIs.</li>\n            </ul>\n          </li>\n          <li>Gradle plugins\n            <ul>\n              <li>intellij 1.0</li>\n              <li>kotlin.jvm 1.5.10</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Configure <code>runPluginVerifier</code></li>\n    </ul>\n  </li>\n  <li>\n    <p>Bug Fixes</p>\n    <ul>\n      <li>\n        <p>Fix Ctrl+Click/Cmd+B/Go To Declaration for Aliases.</p>\n      </li>\n      <li>\n        <p>Don't index non-canonical names.<br>\n          The non-canonical name for a nested <code>defmodule</code> is the Alias given to that <code>defmodule</code> call.  While that name should be resolvable within the parent modular, it should not be indexed because the index is for the global scope.</p>\n        <p>Prevents <code>defmodule Enum</code> in</p>\n        <div><pre><span>defmodule</span> <span>ExJsonSchema</span>.<span>Validator</span>.<span>Error</span> <span>do</span>\n  <span>..</span>.\n  <span>defmodule</span> <span>Enum</span> <span>do</span>\n    <span>..</span>.\n  <span>end</span>\n  <span>..</span>.\n<span>end</span></pre><div>\n          \n            \n              \n            \n            \n              \n            \n          \n        </div></div>\n        <p>\n          from being indexed as <code>Enum</code>, which hides the decompiled version from the standard library because\n          source references are favored over decompiled versions when resolving references.\n        </p>\n      </li>\n      <li>\n        <p>Reference Resolution</p>\n        <ul>\n          <li>\n            <p>\n              Only favor same file Module resolutions if they are valid<br>\n              Invalid same file results can occur for prefix matches, but if only prefix matches are available, then a\n              whole project search should occur instead of only when there are no same file <code>ResolveResult</code>\n              of either validity.\n            </p>\n          </li>\n          <li>\n            <p>\n              Include library sources in <code>Module#multiResolveProject</code> <code>GlobalSearchScope</code><br>\n              Ensures that library sources can be returned, which are favored over decompiled libraries, so that\n              <code>__using__</code> macros can be followed.\n            </p>\n          </li>\n          <li>\n            <p>\n              Protect from <code>Module</code> reference element not having a <code>VirtualFile</code> when checking if\n              a test file.\n            </p>\n          </li>\n          <li>\n            <p>Fix <code>QualifiableAliasImpl#fullyQualifiedName</code></p>\n            <ul>\n              <li>\n                Include qualifier of <code>MultipleAliases</code><br>\n                In an <code>alias</code> line like <code>alias Myapp.MyContext.{Schema1, Schema2}</code>,\n                <code>Schema1</code> would think its <code>fullyQualifiedName</code> was only <code>Schema1</code>, when\n                it should included the <code>fullyQualifiedName</code> of the qualifier, <code>MyApp.MyContext</code>\n                too. This leads to the correct <code>Schema1</code> fully-qualified name of\n                <code>MyApp.MyContext.Schema1</code>.&nbsp; This fix makes references to <code>Schema1</code> resolve to\n                both the <code>alias</code> and the <code>defmodule</code>.\n              </li>\n              <li>\n                Include qualifier of <code>MultipleAliases</code> for deep aliases<br>\n                In an <code>alias</code> line like\n                <code>alias Myapp.MyContext.{NestedContext1.Schema1, NestedContext2.Schema2}</code>,\n                <code>Schema1</code> would think its <code>fullyQualifiedName</code> was only\n                <code>NestedContext1.Schema1</code>, when it should included the <code>fullyQualifiedName</code> of the\n                qualifier, <code>MyApp.MyContext</code> too.&nbsp; This leads to the correct <code>Schema1</code>\n                fully-qualified name of <code>MyApp.MyContext.NestedContext.Schema1</code>.&nbsp; This fix makes\n                references to <code>Schema1</code> resolve to both the <code>alias</code> and the\n                <code>defmodule</code>.\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>In LEEx Templates</p>\n            <ul>\n              <li>Don't check for implicit imports at top of template file if there is a view file<br>\n                The implicit imports should come last, after the view file has been processed.</li>\n              <li>Ignore call definition clauses expressions that can't contain an assign\n                <ul>\n                  <li>Atom keywords (<code>false</code>, <code>true</code>, <code>nil</code>)</li>\n                  <li>Maps</li>\n                  <li>Structs</li>\n                  <li>Keyword lists</li>\n                  <li>Strings and charlists</li>\n                </ul>\n              </li>\n              <li>Don't follow variables for assigns<br>\n                For now, don't follow variables to look for assigns.</li>\n              <li>\n                Fix finding assigns in <code>|&gt; case do ... end</code><br>\n                <code>None</code> calls were ignored, but when <code>case</code> is used in a pipeline it is a\n                <code>None</code> since it has no literal arguments and only resolved arguments, so it was being\n                ignored.\n              </li>\n              <li>Ignore Lists and Aliases when resolving assigns</li>\n              <li>\n                Fix resolve assigns in <code>if</code>s<br>\n                Only looked in <code>stab</code> of the <code>doBlock</code>, but the <code>else</code> is in the\n                <code>blockList</code>.\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>Don't use the same path for actual aliases and defmodules when resolving aliases<br>\n              Prevents a case of an exact match and its namespace both being marked as valid (exact matches).</p>\n          </li>\n          <li>\n            <p>Types</p>\n            <ul>\n              <li>\n                Don't generate references for map key optionality (<code>required/1</code> and <code>optional/1</code>)\n              </li>\n              <li>Don't create a reference to <code>...</code> in lists in type specs.</li>\n              <li>Look above <code>ElixirStabBody</code> for <code>ancestorTypeSpec</code>.</li>\n              <li>\n                Generate <code>Callable</code> reference for <code>unquote</code> in typespec instead of\n                <code>Type</code> reference.\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>\n              Allow modular names to resolve to multiple modulars<br>\n              Fix <code>:systemd.ready()</code> not resolving because <code>:systemd</code> only exists as a decompiled\n              file from source because it is Erlang and there is no preference given to different MIX_ENVs.&nbsp; All\n              MIX_ENV <code>defmodule :systemd</code> are returned for the <code>:systemd</code> and all of them are\n              checked for <code>ready/0</code>.\n            </p>\n          </li>\n          <li>\n            <p>Fix resolving qualified calls that are defined through use</p>\n            <p>\n              Resolving qualified calls only used <code>Modular.callDefinitionClauseCallFoldWhile</code>, which ignores\n              all non call definition, which means it ignored the <code>use</code>, but switching to use\n              <code>org.elixir_lang.psi.scope.call_definition_clause.MultiResolve</code> <code>PsiScopeProcessor</code>\n              used for unqualified calls, but starting on the modular call of the qualifier, all the <code>use</code>\n              handling that works for unqualified calls also works for qualified calls now.\n            </p>\n            <p>\n              This fixes resolving <code>MyAppWeb.Endpoint.config_change(changed, removed)</code> in\n              <code>MyApp.Application.config_change/3</code> because\n              <code>use Phoenix.Endpoint, otp_app: :my_app</code> in <code>MyAppWeb.Endpoint</code> is now walked for\n              qualified calls.\n            </p>\n          </li>\n          <li>\n            <p>Fix resolving variables to parameters that are both pattern matched and defaulted</p>\n            <p>In functions like</p>\n            <div><pre><span>def</span> <span>f</span>(%<span>Struct</span>{} <span>=</span> s <span>\\\\</span> %<span>Struct</span>{}) <span>do</span>\n  s\n<span>end</span></pre><div>\n              \n                \n                  \n                \n                \n                  \n                \n              \n            </div></div>\n            <p>\n              <code>s</code> in the body would not resolve to the <code>s</code> parameter because the default\n              parameter had to be <code>PsiNamedElement</code>, that is a variable directly. Instead, recurse on any\n              operand before the <code>\\\\</code> to support pattern matching too.\n            </p>\n          </li>\n          <li>\n            <p>\n              Use <code>keepProcessing()</code> in <code>MultiResolve.addToResolveResults</code> instead of specific\n              return values\n            </p>\n            <p>\n              Fixes <code>def</code> in <code>def default_host_flag, do: \"--host</code> resolving as an invalid match to\n              <code>default_host_flag</code> instead of search the implicit imports for <code>defmacro def</code>.\n            </p>\n          </li>\n          <li>\n            <p>\n              The <code>nameIdentifier</code> for a <code>defdelegate</code> is the first argument, not the\n              <code>as:</code><br>\n              The <code>as:</code> is the name in the <code>to:</code> module only.\n            </p>\n          </li>\n          <li>\n            <p>Fix <code>defdelegate</code> <code>MultiResolve</code></p>\n            <ol>\n              <li>I had flipped the head name and <code>as</code> name for checking for a name match</li>\n              <li>\n                I only counted the <code>defdelegate</code> as matching if the <code>as</code> name as found in\n                <code>to</code> module, but if the head alone is prefixed by the name then the head should be a\n                ResolveResult element even if the <code>to</code> or <code>as</code> can't be found\n              </li>\n              <li>\n                Inside the <code>to</code>, I only checked if the children were call definition clauses, but this meant\n                that all the <code>for</code> handling was ignored, so start a new <code>resolveResults()</code> for\n                each modular.\n              </li>\n            </ol>\n          </li>\n          <li>\n            <p>Fix <code>toModulars</code> not returning all modulars<br>\n              <code>fullyResolve</code> only touched the first modular.</p>\n          </li>\n          <li>\n            <p>Favor complete valid results over incomplete invalid earlier bindings for variables.</p>\n          </li>\n          <li>\n            <p>Ecto</p>\n            <ul>\n              <li>\n                Don't generate reference for <code>assoc/2</code> pseudo-function in\n                <code>join(..., _ in assoc(_, _))</code>\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>\n              Fix unaliasing multiple aliases<br>\n              <code>UnaliasName</code> still assumed that <code>fullyQualifiedName</code> included the qualifier, but it\n              is just the lexical qualifier now.\n            </p>\n          </li>\n          <li>\n            <p>\n              Check for <code>MULTIPLE_ALIASES_QUALIFIER</code> in <code>ResolveState</code> for prefix matches.<br>\n              Fixes resolving <code>SSH.Key</code> to <code>Foo.SSH.Key</code> when the alias is\n              <code>alias Foo.{SSH, ...}</code>.\n            </p>\n          </li>\n          <li>\n            <p>Ignore type variables in type restrictions when resolving normal variables.</p>\n          </li>\n          <li>\n            <p>\n              Fix <code>withSelf</code> for <code>childExpressions</code> <code>siblingExpressions</code> call<br>\n              While refactoring the walk, I copied the call for siblings, which shouldn't included self.&nbsp; Children\n              should include self, or the first expression is missed which showed up as <code>Repo.transaction</code>\n              not being found because <code>transaction</code> is the first <code>def</code> inside an <code>if</code>\n              in <code>Ecto.Repo.__using__</code>'s <code>quote</code> block.\n            </p>\n          </li>\n          <li>\n            <p>Don't try to resolve keys/fields of a capture.</p>\n          </li>\n          <li>\n            <p>Don't generate reference for <code>assoc</code> in <code>*join*: .. in assoc(..., ...)</code>.<br>\n              Already worked for <code>join/3</code> calls, extend to keyword syntax too.</p>\n          </li>\n          <li>\n            <p>\n              Fix resolving references to <code>Modulars</code> when resolved is in BEAM file<br>\n              The check to see if the resolved was a modular only worked for source elements because it checked if it\n              was a <code>Call</code>, but decompiled modules in BEAM files are <code>ModuleImpls</code>.\n            </p>\n          </li>\n          <li>\n            <p>Fix logic error when ignored pinned variables as declaration sites</p>\n            <p>The logic was supposed to be that</p>\n            <ul>\n              <li>If it is pinned, keep searching</li>\n              <li>If it is not pinned, check the operation as a Call</li>\n            </ul>\n            <p>\n              ... but, the code was <code>operatorText != \"^\" &amp;&amp; execute(match as Call, state)</code> which\n              meant that if the <code>operatorText</code> was <code>\"^\"</code>, then the whole expression was\n              <code>false</code>, which meant <code>keepProcessing</code> was <code>false</code>, so any pin stopped the\n              processing for other unpinned parameters after the pin in addition to processing in the outer scope of the\n              pin.\n            </p>\n          </li>\n          <li>\n            <p>\n              Prefer source only for target candidates for Go To Declaration and not all ResolveResults.<br>\n              Ensures that functions only defined in decompiled Modules can be found because the Module's ResolveResults\n              include the decompiled Module in addition to the source ones.\n            </p>\n          </li>\n          <li>\n            <p>\n              Don't prefer source over decompiled in <code>ResolveResultOrderedSet</code><br>\n              Preference is now handled in <code>Resolver</code>, so that source preference only happens on\n              Go To Declaration and not for <code>multiResolve</code> because that needs decompiled Modulars for\n              compile-time <code>for</code> loops that are too complex to infer.\n            </p>\n          </li>\n          <li>\n            <p>Use primary arity instead of final for resolving Callables</p>\n            <p>Fixes <code>unquote</code> in <code>def unquote(...)() do</code> not resolving.</p>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>\n          Filter out decompiled private functions from completions<br>\n          If they are only available as decompiled functions, it is unlikely we have the source available to make them\n          public, which was the reasoning to allow private functions at all.\n        </p>\n      </li>\n      <li>\n        <p>Decompiling</p>\n        <ul>\n          <li>Include module name for \"No decompiled source function\" errors</li>\n          <li>Unquote <code>and</code> when not and/2<br>\n            Fixes decompiling <code>:hipe_arm_encode</code>.</li>\n          <li>\n            <code>unquote</code> <code>false</code> when decompiling.<br>\n            Fixes decompiling <code>:thrift_json_parser</code>. Add <code>true</code> to the <code>Unquote</code> list\n            too since it would have the same issue.\n          </li>\n          <li>Unquote <code>in</code> when not <code>in/2</code><br>\n            Fix decompiling <code>:digraph_utils</code></li>\n          <li>Use <code>containingFile.originalFile</code> for <code>resolve.Module.multiResolveProject</code><br>\n            Ensures <code>VirtualFile</code> is available for decompiled files.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Performance</p>\n        <ul>\n          <li>\n            <p>Don't use <code>.navigationElement</code> for <code>Variants</code></p>\n            <p>\n              Using <code>navigationElement</code> forces parsing of the decompiled source, which isn't necessary whe\n              only showing the lookup string.\n            </p>\n          </li>\n          <li>\n            <p>Remove <code>ModuleOwner</code> interface</p>\n            <ul>\n              <li>\n                <code>BeamFileImpl</code> is known to have only 1 module in it, so it makes the code more complicated to\n                make it act like source files.\n              </li>\n              <li>\n                Don't use <code>getChildrenByType</code>, as it causes the decompiled source to be parsed, which is slow\n                and unnecessary since all the metadata for modules is available from the binary format.\n              </li>\n            </ul>\n          </li>\n          <li>\n            <p>Get project from parent in decompiled Module and CallDefinition<br>\n              Not doing this causes an unnecessary parsing of the decompiled source.</p>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Fix infinite recursion in <code>ElixirVisitor#visitLiteralSigilLine</code></p>\n      </li>\n      <li>\n        <p>Show more scope for keyword key Go To Definition</p>\n        <ul>\n          <li>\n            Always show the keyword pair, instead of just the keyword key, so that the value being assigned to the key\n            can be seen before Go To.\n          </li>\n          <li>\n            Show the location at the path relative to the content root and the line number as <code>live_modal</code>\n            may be used more than once in the same file.\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Put <code>entrance</code> as initial visited in <code>module.Variants</code>.</p>\n      </li>\n      <li>\n        <p>\n          Check if <code>PsiElement</code> has been visited before walking <code>quote</code> and <code>__using__</code>\n        </p>\n      </li>\n      <li>\n        <p>\n          Don't mark qualified calls as unresolved in \"Elixir References\" inspection<br>\n          I don't have a good approach for resolving struct fields or map keys for now, don't mark them as unresolved as\n          it clutters finding unresolved calls I expect to work.\n        </p>\n      </li>\n      <li>\n        <p>\n          Don't assume <code>PsiFile#virtualFile</code> is <code>NotNull</code> in\n          <code>PsiElement.moduleWithDependentsScope</code>.\n        </p>\n      </li>\n      <li>\n        <p>\n          Don't assume <code>PsiFile#virtualFile</code> is <code>NotNull</code> in\n          <code>AtNonNumericOperation.computeReference()</code>.\n        </p>\n      </li>\n      <li>\n        <p>\n          <code>putInitialVisitedElement</code> in <code>variable.MultiResolve</code><br>\n          Fixes resolving variables through <code>use</code> statements for variables in the body of\n          <code>defmodule</code> blocks.\n        </p>\n      </li>\n      <li>\n        <p>Log when <code>VISITED_ELEMENT_SET</code> is <code>null</code> instead of erroring.</p>\n      </li>\n      <li>\n        <p>\n          Fix <code>resolvePrimaryArity</code> for <code>|&gt; case do</code><br>\n          <code>resolvedPrimaryArity</code> did not add both the doBlock's arity and the arity from the\n          <code>|&gt;</code> at the same time.&nbsp; If the pipe was there, the <code>do</code> was ignored because the\n          pre-existing <code>resolvePrimaryArity</code> was not used if the normal primary arity of the call was zero,\n          which is the case for <code>|&gt; case do</code>.\n        </p>\n      </li>\n      <li>\n        <p>\n          Find module for elements in libraries<br>\n          Elements in libraries don't have a <code>Module</code> from <code>ModuleUtil.findModuleForPsiElement</code>,\n          so scan the element's project's module's content roots for the closest <code>Module</code> for libraries.\n        </p>\n      </li>\n      <li>\n        <p><code>prependQualifiers</code> when typing an alias on a new line in the body of a function.</p>\n      </li>\n      <li>\n        <p>\n          Don't descend into <code>quote</code> blocks if the call being resolved is given to an <code>unquote</code> in\n          the <code>quote</code> block.\n        </p>\n      </li>\n      <li><code>updateSinceUntilBuild</code> to prevent breaking in future IDEs.</li>\n      <li>Check if modules loaded before using <code>findModuleForPsiElement</code>.</li>\n      <li>Use <code>BasePlatformTestCase</code> instead of <code>LightCodeInsightTestCase</code> because <code>LightCodeInsightTestCase</code> is deprecated.</li>\n    </ul>\n  </li>\n</ul>","dependencies":["com.intellij.modules.lang"],"optionalDependencies":["com.intellij.modules.java","org.jetbrains.erlang"],"since":"211.7442","until":"212.*","sourceCodeUrl":"https://github.com/KronicDeth/intellij-elixir","size":7289457}